# 适配器模式

## 1，简介

### 1.1，什么是适配器模式
当想要使用一个类，但是累的接口不符合要求没，这时候可以考虑使用适配器模式，将接口进行适配，从而达到目的。

**定义：**
> 将一个类的接口转换成客户希望的另一个接口，Adapter将原本不兼容不能一起工作的那些类可以一起工作。

### 1.2，为什么要有适配器模式
> 经常的情况下，在一个系统中，系统的数据和行为都是正确的，但是接口类却不符合使用，这时候就需要使用适配器模式，目的是将控制范围之外的原有的对象和接口匹配使用，适配器模式的主要应用于系统服用一些现存的类，但是接口于复用环境要求不一致的情况。

> 这是一种补偿模式。

**分类:**
> - 类适配器模式
> - 对象适配器模式

## 2，实现
本实现主要阐述对象适配器模式的实现。
## 2.1，角色

角色|关系|作用
:-:|:-:|:-:
被适配者（Adaptee）|不能满足使用要求的对象或者接口类| 需要适配的类
适配器（Adapter）|组合目标对象和被适配者|客户期待的接口和类
对象目标（Target）|目标接口| 内部封装一个adaptee对象，并定义其接口

## 2.2，具体实现
本文使用的案例是依旧是煮面的例子，本人在厨房做了一碗西红柿鸡蛋面，里边需要加一些。接口只负责加工了西红柿鸡蛋面，没办法加一些黑胡椒呀啥的需要额外进行的调料，因此，可以让服务员帮忙添加黑胡椒进行调料，这个案例中，煮面是被适配者，调味是目标接口，需要使用一个服务员作为适配，才能完成鸡蛋面添加胡椒的工作。

**被适配者角色：**
```
public interface Kitchen {

    public void cookingNoodles();
}

public class XihongshiEgg implements Kitchen {

  @Override
  public void cookingNoodles() {
    System.out.println("做面： 西红柿鸡蛋面");
  }
}
```
**目标角色：**
```
public interface Flavoring {

  public void addPepper();

}
```
**适配器：**
```
public class Waiter extends XihongshiEgg implements Flavoring {

  @Override
  public void addPepper() {
    super.cookingNoodles();
    System.out.println("面里加点胡椒");
  }
}
```
**测试：**
```
public class AdapterDemo {

  public static void main(String[] args) {
    Waiter waiter = new Waiter();
    waiter.addPepper();
  }
}
```
**输出：**
```
做面： 西红柿鸡蛋面
面里加点胡椒
```

## 3，优缺点
**优点：**
> - 让两个没有关系的类组合起来解决某个问题
> - 提高了类的复用性，通过适配器可以实现一些原来不符合使用的接口，通过适配满足使用要求
> - 使用适配器，可以调用自己开发的功能，能够很好自然的扩展系统

**缺点：**
> - 使用过多容易让系统比较乱，难以维护

## 4，适用场景
> - 系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。
> - 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。

**Spring中的适配器模式**
> AOP