# 1. Data Structure(java version)
<!-- TOC -->autoauto- [1. Data Structure(java version)](#1-data-structurejava-version)auto  - [1.1. ， 算法复杂度分析](#11--算法复杂度分析)auto    - [1.1.1. ， 时间复杂度分析](#111--时间复杂度分析)auto    - [1.1.2. ， 空间复杂度分析](#112--空间复杂度分析)auto  - [1.2. , 线性存储结构](#12--线性存储结构)auto    - [1.2.1. ， 数组](#121--数组)auto    - [1.2.2. ， 查找算法](#122--查找算法)auto    - [1.2.3. ， 栈](#123--栈)auto    - [1.2.4. ， 队列](#124--队列)auto    - [1.2.5. ， 单链表](#125--单链表)auto    - [1.2.6. ， 循环链表](#126--循环链表)auto    - [1.2.7. ， 双向循环链表](#127--双向循环链表)auto    - [1.2.8. ， 递归](#128--递归)auto  - [1.3. , 排序算法](#13--排序算法)auto    - [1.3.1. ， 冒泡排序](#131--冒泡排序)auto    - [1.3.2. ， 快速排序](#132--快速排序)auto    - [1.3.3. ， 插入排序](#133--插入排序)auto    - [1.3.4. ， 希尔排序](#134--希尔排序)auto    - [1.3.5. ， 选择排序](#135--选择排序)auto    - [1.3.6. ， 归并排序](#136--归并排序)auto    - [1.3.7. ， 基数排序](#137--基数排序)auto  - [1.4. , 树](#14--树)auto    - [1.4.1. ， 二叉树](#141--二叉树)auto    - [1.4.2. ， 顺序存储二叉树](#142--顺序存储二叉树)auto    - [1.4.3. ， 线索二叉树](#143--线索二叉树)auto    - [1.4.4. ， Hoffman树](#144--hoffman树)auto    - [1.4.5. ， 二叉排序树](#145--二叉排序树)auto    - [1.4.6. ， 平衡二叉树](#146--平衡二叉树)auto    - [1.4.7. ， 其他树](#147--其他树)auto  - [1.5. ，哈希表](#15-哈希表)auto    - [1.5.1. ， 散列函数设计](#151--散列函数设计)auto    - [1.5.2. ，散列函数主要方法](#152-散列函数主要方法)auto    - [1.5.3. ， 散列冲突](#153--散列冲突)auto  - [1.6. ，图](#16-图)auto    - [1.6.1. ， 图的概念](#161--图的概念)auto    - [1.6.2. ， 图的遍历](#162--图的遍历)auto      - [1.6.2.1. ， 深度优先搜索算法](#1621--深度优先搜索算法)auto      - [1.6.2.2. ， 广度优先搜索算法](#1622--广度优先搜索算法)auto      - [1.6.2.3. ， 代码实现](#1623--代码实现)autoauto<!-- /TOC -->
Refer to [This Vedio][StudyVideo]  

-------
## 1.1. ， 算法复杂度分析
### 1.1.1. ， 时间复杂度分析
### 1.1.2. ， 空间复杂度分析

-------
## 1.2. , 线性存储结构
### 1.2.1. ， 数组
### 1.2.2. ， 查找算法
### 1.2.3. ， 栈
### 1.2.4. ， 队列
### 1.2.5. ， 单链表
### 1.2.6. ， 循环链表
### 1.2.7. ， 双向循环链表
### 1.2.8. ， 递归
--------

## 1.3. , 排序算法
### 1.3.1. ， 冒泡排序
### 1.3.2. ， 快速排序
### 1.3.3. ， 插入排序
### 1.3.4. ， 希尔排序
### 1.3.5. ， 选择排序
### 1.3.6. ， 归并排序
### 1.3.7. ， 基数排序
--------

## 1.4. , 树
### 1.4.1. ， 二叉树
### 1.4.2. ， 顺序存储二叉树
### 1.4.3. ， 线索二叉树
### 1.4.4. ， Hoffman树
### 1.4.5. ， 二叉排序树
### 1.4.6. ， 平衡二叉树
### 1.4.7. ， 其他树
--------

## 1.5. ，哈希表
​		Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。
​		散列表,它是基于快速存取的角度设计的，也是一种典型的“**==空间换时间==**”的做法。顾名思义，该数据结构可以理解为一个线性表，但是其中的元素不是紧密排列的，而是可能存在空隙。
​       散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。
### 1.5.1. ， 散列函数设计
散列函数的设计原则
- 计算简单
- 分布均匀
### 1.5.2. ，散列函数主要方法
- 直接定址法：[样例代码][HashCode]
- 平方取中法

- 数据分析法（例如手机号码），对数据比较了解推荐使用

- 取余法

- 随机数法，存储地址=random();

### 1.5.3. ， 散列冲突
- 开放地址法

  - 线性探测法
  - 二次探测法
  - 再哈希法（多个散列函数，一般三个可以解决大部分问题）

- 链地址法
--------

## 1.6. ，图
### 1.6.1. ， 图的概念
- 顶点vertex
- 边 edge
- 邻接
- 路径
- 有向图和无向图
- 带权图
### 1.6.2. ， 图的遍历
#### 1.6.2.1. ， 深度优先搜索算法
- 栈
#### 1.6.2.2. ， 广度优先搜索算法
- 堆
#### 1.6.2.3. ， 代码实现



[StudyVideo]: https://www.bilibili.com/video/av33835237/ "数据结构与算法基础-java版"
[HashCode]: ./src/main/java/com/lei/learn/datastructure/hash/HashTable.java "hash table"
